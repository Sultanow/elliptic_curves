#ifndef _SMALLJAC_INCLUDE_
#define _SMALLJAC_INCLUDE_

/*
    Copyright (c) 2007-2014 Andrew V. Sutherland
    See LICENSE file for license details.
*/

#ifdef __cplusplus
extern "C" {
#endif

/*
	IMPORTANT NOTES
	
	genus 1 and genus 2 curves are now both supported simultaneously.  Keep SMALLJAC_GENUS defined to 2.
	Support for quadratic number fields has been added.
	Support for genus 2 curves defined by a y^2=sextic is now fully implemented (and nearly as fast as y^2=quintic).
	More to come...
*/

#define SMALLJAC_VERSION_STRING	"smalljac version 4.1.3"

#define SMALLJAC_GENUS			2				// genus 1 and 2 (and limited functionality in genus 3) work when SMALLJAC_GENUS is set to 2, do not change this.

#define SMALLJAC_MAX_GENUS	4				// genus  4 curves only supported for pointcounting
#define SMALLJAC_MAX_DEGREE	10					
#define SMALLJAC_RETRIES		40				// number of random elements to use to test group exponents 
#define SMALLJAC_FULL_P			(1UL<<33)		// determines when to do a full search of the Weil interval in genus 1(only)
#define SMALLJAC_MAX_COUNT_P	(1<<25)		// genus independent
#define SMALLJAC_BIG_COUNT_P	3600000		// experimentally determined on an AMD Athlon-64 4800+,  YMMV

#define SMALLJAC_ST_MAX_MOMENT	20
#define SMALLJAC_G1_ST_GROUPS		3
#define SMALLJAC_G2_ST_GROUPS		52

// the inlines below supercede the constants SMALLJAC_TINY_P, SMALLJAC_COUNT_P and SMALLJAC_MAX_P
static inline int smalljac_tiny_p (int g)				// tiny primes get special handling
{
	switch (g) {
	case 1: return 3;
	case 2: return 61;		// Must be at least 29 (need unique group order in Weil interval given a1).  p > 61 ensures a1 < p/2 (so a1 mod p determines a1).
	case 3: return 47;		// Must be at least 47 (need unique group order in Weil interval given a1),  p > 143 to ensure a1 < p/2.
	}
	return 0;				// perhaps should abort here
}

// these are generic bounds, for special curves one can go higher
static inline unsigned long smalljac_max_p (int g)
{
	// must also be less than MPZ_MAX_ENUM_PRIME
	if ( g==1 ) return (1UL<<44);			// this could be increased to as much as 2^63 by increasing BSGS_MAX_STEPS in ecurve.c and in ff2ec.c (and increasing MPZ_MAX_ENUM_PRIME)
    if ( g==2 ) return (1UL<<32);
	return (1UL<<30);						// we could increase this to 2^32 in genus 2 with a few changes (group order won't fit in 64 bits)
}

static inline int smalljac_count_p (int g)		// primes below count_p will use point-counting to get a1
{
	switch (g) {
	case 1: return 1024;
	case 2: return 320000;					// crossover point determined on an AMD Phenom II 3.0GHz - YMMV
	}
	return smalljac_max_p (g);	
}

#if SMALLJAC_GENUS == 2
#define SMALLJAC_3TOR_P		320000			// crossover point to start using 3-torsion (should never be less than COUNT_P)
#define SMALLJAC_TABBITS		24				// slightly larger than ideal
#define SMALLJAC_INIT_COUNT_P	(1<<26)
#endif
#if SMALLJAC_GENUS == 3
#define SMALLJAC_PADIC_P		(1<<14)			// Should not be greater than 2^21 - group computation code assumes order < 2^63
#define SMALLJAC_TABBITS		19
#define SMALLJAC_INIT_COUNT_P	(1<<30)			// allocate extra space in genus 3, we always want to be using this
#endif


// bit-masks for flags parameter (note these have moved from version 3.0!)
#define SMALLJAC_GOOD_ONLY  	0x1 				// only callback for good primes
#define SMALLJAC_SPLIT4		0x2				// only process half the primes mod 4, SMALLJAC_HIGH4 set => p mod 4 > 2, else p mod 4 <= 2
#define SMALLJAC_SPLIT8		0x4				// similarly for 8, 16, ..., 256 - allows primes to be very efficiently partitioned among up to 256 jobs
#define SMALLJAC_SPLIT16		0x8
#define SMALLJAC_SPLIT32		0x10
#define SMALLJAC_SPLIT64		0x20
#define SMALLJAC_SPLIT128		0x40
#define SMALLJAC_SPLIT256		0x80
#define SMALLJAC_A1_ONLY    		0x100    			// only compute a1 coefficient
#define SMALLJAC_HIGH4			0x200
#define SMALLJAC_HIGH8			0x400
#define SMALLJAC_HIGH16		0x800
#define SMALLJAC_HIGH32		0x1000
#define SMALLJAC_HIGH64		0x2000
#define SMALLJAC_HIGH128		0x4000
#define SMALLJAC_HIGH256		0x8000
#define SMALLJAC_FILTER			0x10000			// flag to permit more general prime filtering - calls callback function with good=-1 to test whether p should be processed
#define SMALLJAC_GROUP		0x20000			// indicates group structure computation rather than L-poly coefficients (currently only support for curves over Q)
#define SMALLJAC_SGROUP		0x40000			// compute only the group structure actually generated by the black box (potentially a subgroup).
											// only relevant when SMALLJAC_GROUP is set
#define SMALLJAC_PRIME_ORDER	0x80000			// only return when the Jacobian has prime order (only supported for curves over Q)
#define SMALLJAC_LOW_ORDER	0x100000		// only return when the order of the Jacobian is less than p^g (only supported for curves over Q)
#define SMALLJAC_A1_ZERO		0x200000		// only return data when a1=0, otherwise sets a1 to SMALLJAC_INVALID_A1
#define SMALLJAC_DEGREE1_ONLY	0x400000		// only return data for degree 1 primes (only relevant over number fields)

#define SMALLJAC_SPLIT			0xFE			// all 2^k split flags
#define SMALLJAC_SPLIT_SHIFT	0
#define SMALLJAC_HIGH			0xFE00			// all 2^k high flags
#define SMALLJAC_HIGH_SHIFT	8

#define SMALLJAC_MAX_JOBS		256

// error codes
#define SMALLJAC_INTERNAL_ERROR		-1			// general unspecified internal error - probably indicates a bug
#define SMALLJAC_INVALID_INTERVAL		-2			// end < start or end > smalljac_max_p(g)
#define SMALLJAC_PARSE_ERROR			-3			// couldn't parse curve string
#define SMALLJAC_UNSUPPORTED_CURVE		-4			// currently curve must be hyperelliptic of genus at most MAX_GENUS
#define SMALLJAC_SINGULAR_CURVE		-5			// curve is singular
#define SMALLJAC_INVALID_PP				-6			// prime power (or prime) required, or prime is too large, or extension degree is invalid or too large
#define SMALLJAC_WRONG_GENUS			-7			// curve may be valid, but it doesn't have the compiled genus (this will go away eventually)
#define SMALLJAC_INVALID_FLAGS			-8			// invalid combination of flag bits set
#define SMALLJAC_FILENOTFOUND			-9			// couldn't find specified data file
#define SMALLJAC_BADFILE				-10			// bad file format
#define SMALLJAC_NODATA				-11			// requested data not present in file
#define SMALLJAC_NOT_OVER_Q			-12			// specified curve is not defined over Q

#define SMALLJAC_CURVE_STRING_LEN		1024


// public interface for Sage, as of smalljac version 4, the prefix smalljac_Qcurve has changed to smalljac_curve (since curves don't have to be defined over Q anymore)
// the following macros provide backward compatibility 
#define smalljac_Qcurve_t		smalljac_curve_t
#define smalljac_Qcurve_init	smalljac_curve_init
#define smalljac_Qcurve_clear	smalljac_curve_clear
#define smalljac_Qcurve_str	smalljac_curve_str
#define smalljac_Qcurve_cm	smalljac_curve_cm

typedef void *smalljac_curve_t;						// private type - we don't want to spell out the details here - see smalljac_internal.h

smalljac_curve_t smalljac_curve_init (char *str, int *err);	// creates a curve over Q, or a number field, from a null-terminated curve specification, either [a1,a2,a3,a4,a6] (a1,...a6 must be integral)
												// or a monic poly f(x) of odd degree with rational coefficients to define y^2 = f(x), err is an optional pointer to an error code
												// curves over number fields Q[z]/(g(z)) are specified in the form "[a1,a2,a3,a4,a6]/(g(z))" or "[f(x)]/(g(z)", where g is in Z[z]
												// and a1,a2,a3,a4,a6 or the coefficients of f(x) are also in Z[z] (currently they must be integral!)
												// some valid examples are "[0,-a,1,-a-1,2*a+1] / (a^2 - a -1)"  and "[x^6 + (z^2+3*z+1)*x^3 + z+5] / (z^3 + 3*z - 2)"
void smalljac_curve_clear (smalljac_curve_t c);	  			// frees memory allocated for curve
char *smalljac_curve_str (smalljac_curve_t c);				// returns a (readonly) pointer to the curve specification used to create the curve
char *smalljac_curve_nf (smalljac_curve_t c);				// returns a ptr to a string of the form "(g(z))" where g is the polynomial defining the number field.  Returns null for Q.
int smalljac_curve_nf_degree (smalljac_curve_t c);			// returns the degree of the number field over which the curve is defined.
int smalljac_curve_genus (smalljac_curve_t c);				// returns the genus of the curve
int smalljac_curve_cm (smalljac_curve_t c);				    // returns true if curve is CM E/Q in Weierstrass form (input must be in Weierstrass form,
                                                            // specified either as [a1,a2,a3,a4,a6] or y^2 + h(x)y = f(x) with deg(h) <= 1 and f monic cubic)

long smalljac_Lpolys (smalljac_curve_t c,					// curve created via smalljac_Qcurve_init
                      unsigned long start,					// start and end specify closed search interval [start,end].  Set start=end=p to compute L_p(T)
                      unsigned long end,				
                      unsigned long flags,					// bitmask of options defined above
                      int (*callback)(smalljac_curve_t c,			// pointer to callback function
                                      unsigned long q,				// prime (or prime power) in [start,end]
                                      int good,						// 1 if good reduction, 0 if bad
                                      long a[],						// n coefficients of L_q(T) with a[0] = a_1
                                      int n,							// either 1 or g for good p, 0 for bad p
                                      void *arg),						// forwarded arg from caller
                     void *arg);								// pass-through arg uninterpreted by smalljac

// simulates smalljac_Lpolys using data file pre-computed using the lpdata program - note that the data is NOT VALIDATED in any way
long smalljac_Lpolys_from_file (char *filename, unsigned long start, unsigned long end, unsigned long flags,
						int (*callback)(smalljac_curve_t curve, unsigned long q, int good, long a[], int n, void *arg), void *arg);
// handles multiple files of the form sprintf("%s_%d_%d.txt", prefix, jobs, jobid), where jobid ranges from 0 to jobs-1
long smalljac_Lpolys_from_files (char *prefix, int jobs, unsigned long start, unsigned long end, unsigned long flags,
						 int (*callback)(smalljac_curve_t curve, unsigned long q, int good, long a[], int n, void *arg), void *arg);

// counts project points over F_p^n for curves defined over Q, assumes good reduction but does not actually verify this, results are undefined in the bad reduction case
long smalljac_curve_points (smalljac_curve_t c, unsigned long p, int n);

// counts affine points on the affine plane curve y^2+h(x)y=f(x) over F_p^n, which need not be smooth or geometrically irreducible
long smalljac_curve_affine_points (smalljac_curve_t c, unsigned long p, int n);

// smalljac_groups has the same interface as smalljac_Lpolys, except instead of an array a[] of L-poly coefficients,
// the array m[] contains the orders of the cyclic factors of J(C/F_p) ~ Z_m[0] x Z_m[1] x ... x Z_m[n-1]
// with m[0] | m[1] | ... | m[n-1] and 1 <= n <= 2g
// only supported for curves over Q
static inline long smalljac_groups (smalljac_curve_t curve, unsigned long start, unsigned long end, unsigned long flags,
							int (*callback)(smalljac_curve_t curve, unsigned long q, int good, long m[], int n, void *arg), void *arg)
    { return smalljac_Lpolys (curve, start, end, flags|SMALLJAC_GROUP, callback, arg); }

// One shot version for computing a single L-poly (or group structure) for curves defined over Q
// Returns the number of coefficients computed (1 or g), 0 for bad reduction, or a negative error code
int smalljac_Lpoly (long a[], char *curve_str, unsigned long p, unsigned long flags);
    
// One shot version for computing a single group structure.  Computes m[0],...,m[n-1] s.t.
// J(C/F_q) is isomorphic to Z_m[0] x ... x Z_m[r] with m[0] | m[1] | ... | m[n-1], where 1 <= n <= 2g.
// Returns n, the number of invariant factors, 0 for bad reduction, or a negative error code
// Currently q must be prime, the curve must be defined over Q, and no flag values are used.
static inline int smalljac_group (long m[], char *curve_str, unsigned long q, unsigned long flags)
    { return smalljac_Lpoly (m, curve_str, q, flags|SMALLJAC_GROUP); }
    
// Computes moments E[a_i^k] for 0 <= i < n and 0 <= k < m of normalized a_i coefficients over primes in [start,end]
// moments should contain space for n*m entries -- the moment for a_i^k will go in the (m*i)+k entry (note 0th moments are set to 1)
// If STgroup is non-null, Sato-Tate group identification will be attempted, and if a sufficiently close match is found a string identifying the group will be returned.
// filter_callback is an optional callback function.  If specified it will be called *before* computing the Lpoly for the prime q, and process data for q iff the return value is nonzero
int smalljac_moments (smalljac_curve_t curve, unsigned long start, unsigned long end, double moments[], int n, int m,
				    char STgroup[16], int (*filter_callback)(smalljac_curve_t curve, unsigned long q, void *arg), void *arg);

// returns the ST group name for the specified genus and index in [0,SMALLJAC_Gx_ST_GROUPS)
int smalljac_STgroup (char STgroup[16], int genus, int index);
    
// Returns data pertaining to a specifeid Sato-Tate group.  In genus 2 this is as specified in Table 8 of FKRS
// All parameters other than genus and STgroup are optional and may be null.
// The array z holds counts of integer values of normalized a_i values.  z[0] is for a1=0, z[1],...,z[5]  is for a2=-2,-1,0,1,2.
// The parameter n must be <= genus and specifies the maximum value of k for which a_i data is returned in z[] and moments[]
// As in the smalljac_moments function, moments of a_i^k will be returned for 0 <= i < n and 0 <= k < m, where m <= SMALLJAC_ST_MOMENTS
int smalljac_STgroup_info (int genus, char *STgroup, char identity_component[16], char component_group[16], int *components,
					 int z[], long moments[], int n, int m);

// Attempts to heuristically identify the Sato-Tate group of the specified curve based on its L-polynomial distribution
// It will terminate as soon as it thinks it has a reasonably accurate identification, and returns TRUE in this case
// If this does not occur before reaching maxp (or smalljac_maxp if maxp = 0),  it will return FALSE
int smalljac_identify_STgroup (smalljac_curve_t c, char STgroup[16], long maxp);

// Lookup genus 1 ST group given z1=dens(a1=0) and the first two moments of a1^2
// The zeroth mometns are ignored, so just the first and second moments of a1^2 are used
int smalljac_lookup_g1_STgroup (char STgroup[16], double z1, double m1sq[3]);

// Lookup genus 2 ST group given z1=dens(a1=0), z2[i]=dens(a2=i-2), and the first few moments of a1^2 and a2
// The zeroth mometns are ignored, so just the first and second moments of a1^2 are used, along with the first, second, and third moments of a2.
int smalljac_lookup_g2_STgroup (char STgroup[16], double z1, double z2[5], double m1sq[3], double m2[4]);

long smalljac_parallel_Lpolys (smalljac_curve_t curve, unsigned long start, unsigned long end, unsigned long flags, int (*callback)(smalljac_curve_t curve, unsigned long q, int good, long m[], int n, void *arg), void *arg);

static inline long smalljac_parallel_groups (smalljac_curve_t curve, unsigned long start, unsigned long end, unsigned long flags, int (*callback)(smalljac_curve_t curve, unsigned long q, int good, long m[], int n, void *arg), void *arg) {
	return smalljac_parallel_Lpolys(curve, start, end, flags|SMALLJAC_GROUP, callback, arg);
}


#ifdef __cplusplus
}
#endif

#endif
